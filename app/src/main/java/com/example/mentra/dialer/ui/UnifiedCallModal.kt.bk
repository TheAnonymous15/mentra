package com.example.mentra.dialer.ui

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectHorizontalDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.blur
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.hapticfeedback.HapticFeedbackType
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalHapticFeedback
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.delay
import kotlin.math.absoluteValue
import kotlin.math.roundToInt

/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UNIFIED CALL MODAL - Futuristic Glassmorphic Design
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles both INCOMING and ACTIVE call states in ONE modal.
 * Features slide-to-answer/reject with visual button movement.
 */

// Color palette
private object CallModalColors {
    val voidBlack = Color(0xFF000308)
    val deepSpace = Color(0xFF030810)
    val nebula = Color(0xFF0A1628)

    val glassCore = Color(0xFF0D1B2A).copy(alpha = 0.95f)
    val glassSurface = Color(0xFF1B2838).copy(alpha = 0.7f)
    val glassHighlight = Color(0xFF00E5FF).copy(alpha = 0.15f)

    val cyberCyan = Color(0xFF00E5FF)
    val neonPurple = Color(0xFF7C4DFF)
    val plasmaBlue = Color(0xFF2979FF)

    val answerGreen = Color(0xFF00E676)
    val answerGreenDark = Color(0xFF00C853)
    val rejectRed = Color(0xFFFF5252)
    val rejectRedDark = Color(0xFFD32F2F)

    val textPrimary = Color.White
    val textSecondary = Color(0xFFB0BEC5)
    val textMuted = Color(0xFF78909C)
}

// Call state for the modal
enum class CallModalState {
    RINGING,    // Incoming call - show slide to answer/reject
    CONNECTING, // Call being connected
    ACTIVE,     // Call in progress - show in-call controls
    ENDED       // Call ended
}

/**
 * Main Unified Call Modal
 */
@Composable
fun UnifiedCallModal(
    phoneNumber: String,
    contactName: String?,
    initialState: CallModalState = CallModalState.RINGING,
    onAnswer: () -> Unit,
    onReject: () -> Unit,
    onEndCall: () -> Unit,
    onMuteToggle: (Boolean) -> Unit = {},
    onSpeakerToggle: (Boolean) -> Unit = {},
    onHoldToggle: (Boolean) -> Unit = {},
    onKeypadPress: (Char) -> Unit = {},
    isMuted: Boolean = false,
    isSpeaker: Boolean = false,
    isOnHold: Boolean = false
) {
    var callState by remember { mutableStateOf(initialState) }
    var callDuration by remember { mutableLongStateOf(0L) }
    var callStartTime by remember { mutableLongStateOf(0L) }

    // Timer for call duration
    LaunchedEffect(callState) {
        if (callState == CallModalState.ACTIVE) {
            callStartTime = System.currentTimeMillis()
            while (callState == CallModalState.ACTIVE) {
                callDuration = (System.currentTimeMillis() - callStartTime) / 1000
                delay(1000)
            }
        }
    }

    // Background with glassmorphic effect
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                Brush.verticalGradient(
                    colors = listOf(
                        CallModalColors.voidBlack,
                        CallModalColors.deepSpace,
                        CallModalColors.nebula
                    )
                )
            ),
        contentAlignment = Alignment.Center
    ) {
        // Animated background particles
        AnimatedBackground()

        // Main modal content
        Column(
            modifier = Modifier
                .fillMaxWidth(0.9f)
                .clip(RoundedCornerShape(32.dp))
                .background(
                    Brush.verticalGradient(
                        colors = listOf(
                            CallModalColors.glassCore,
                            CallModalColors.glassSurface
                        )
                    )
                )
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Call status indicator
            CallStatusBadge(callState)

            Spacer(modifier = Modifier.height(24.dp))

            // Avatar with pulse animation for ringing
            CallerAvatar(
                contactName = contactName,
                isRinging = callState == CallModalState.RINGING
            )

            Spacer(modifier = Modifier.height(20.dp))

            // Caller info
            Text(
                text = contactName ?: phoneNumber,
                color = CallModalColors.textPrimary,
                fontSize = 28.sp,
                fontWeight = FontWeight.Bold
            )

            if (contactName != null) {
                Text(
                    text = phoneNumber,
                    color = CallModalColors.textSecondary,
                    fontSize = 16.sp
                )
            }

            Spacer(modifier = Modifier.height(8.dp))

            // Call duration or status text
            when (callState) {
                CallModalState.RINGING -> {
                    Text(
                        text = "Incoming Call",
                        color = CallModalColors.cyberCyan,
                        fontSize = 14.sp,
                        fontWeight = FontWeight.Medium
                    )
                }
                CallModalState.CONNECTING -> {
                    Text(
                        text = "Connecting...",
                        color = CallModalColors.neonPurple,
                        fontSize = 14.sp,
                        fontWeight = FontWeight.Medium
                    )
                }
                CallModalState.ACTIVE -> {
                    Text(
                        text = formatDuration(callDuration),
                        color = CallModalColors.answerGreen,
                        fontSize = 18.sp,
                        fontWeight = FontWeight.Bold
                    )
                }
                CallModalState.ENDED -> {
                    Text(
                        text = "Call Ended",
                        color = CallModalColors.textMuted,
                        fontSize = 14.sp
                    )
                }
            }

            Spacer(modifier = Modifier.height(32.dp))

            // Controls based on state
            AnimatedContent(
                targetState = callState,
                transitionSpec = {
                    fadeIn(animationSpec = tween(300)) togetherWith
                    fadeOut(animationSpec = tween(300))
                },
                label = "callControls"
            ) { state ->
                when (state) {
                    CallModalState.RINGING -> {
                        SlideToAnswerReject(
                            onAnswer = {
                                callState = CallModalState.CONNECTING
                                onAnswer()
                                // Transition to active after short delay
                                callState = CallModalState.ACTIVE
                            },
                            onReject = {
                                callState = CallModalState.ENDED
                                onReject()
                            }
                        )
                    }
                    CallModalState.CONNECTING -> {
                        CircularProgressIndicator(
                            color = CallModalColors.cyberCyan,
                            modifier = Modifier.size(48.dp)
                        )
                    }
                    CallModalState.ACTIVE -> {
                        InCallControls(
                            isMuted = isMuted,
                            isSpeaker = isSpeaker,
                            isOnHold = isOnHold,
                            onMuteToggle = onMuteToggle,
                            onSpeakerToggle = onSpeakerToggle,
                            onHoldToggle = onHoldToggle,
                            onKeypadPress = onKeypadPress,
                            onEndCall = {
                                callState = CallModalState.ENDED
                                onEndCall()
                            }
                        )
                    }
                    CallModalState.ENDED -> {
                        // Auto dismiss after showing ended state
                        LaunchedEffect(Unit) {
                            delay(1500)
                        }
                    }
                }
            }
        }
    }
}

/**
 * Slide to Answer/Reject Control with visual button movement
 */
@Composable
private fun SlideToAnswerReject(
    onAnswer: () -> Unit,
    onReject: () -> Unit
) {
    val configuration = LocalConfiguration.current
    val density = LocalDensity.current
    val haptic = LocalHapticFeedback.current

    val trackWidth = configuration.screenWidthDp.dp * 0.8f
    val buttonSize = 70.dp
    val trackWidthPx = with(density) { trackWidth.toPx() }
    val buttonSizePx = with(density) { buttonSize.toPx() }
    val maxDragPx = (trackWidthPx - buttonSizePx) / 2

    // Drag offset - positive = right (answer), negative = left (reject)
    var dragOffset by remember { mutableFloatStateOf(0f) }
    var isDragging by remember { mutableStateOf(false) }
    var actionTriggered by remember { mutableStateOf(false) }

    // Animate back to center when not dragging
    val animatedOffset by animateFloatAsState(
        targetValue = if (isDragging || actionTriggered) dragOffset else 0f,
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy,
            stiffness = Spring.StiffnessLow
        ),
        label = "dragOffset"
    )

    // Calculate progress (0 to 1 for answer, 0 to -1 for reject)
    val progress = (animatedOffset / maxDragPx).coerceIn(-1f, 1f)
    val answerProgress = progress.coerceAtLeast(0f)
    val rejectProgress = (-progress).coerceAtLeast(0f)

    // Threshold reached indicators
    val answerThresholdReached = answerProgress > 0.85f
    val rejectThresholdReached = rejectProgress > 0.85f

    // Pulse animation for indicators
    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
    val pulseScale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = 1.2f,
        animationSpec = infiniteRepeatable(
            animation = tween(600, easing = EaseInOutSine),
            repeatMode = RepeatMode.Reverse
        ),
        label = "pulseScale"
    )

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.fillMaxWidth()
    ) {
        // Instructions
        Text(
            text = when {
                answerThresholdReached -> "Release to Answer"
                rejectThresholdReached -> "Release to Decline"
                else -> "Slide to Answer or Decline"
            },
            color = when {
                answerThresholdReached -> CallModalColors.answerGreen
                rejectThresholdReached -> CallModalColors.rejectRed
                else -> CallModalColors.textMuted
            },
            fontSize = 14.sp,
            fontWeight = if (answerThresholdReached || rejectThresholdReached)
                FontWeight.Bold else FontWeight.Normal
        )

        Spacer(modifier = Modifier.height(16.dp))

        // Track with sliding button
        Box(
            modifier = Modifier
                .width(trackWidth)
                .height(buttonSize + 16.dp)
                .clip(RoundedCornerShape(40.dp))
                .background(
                    Brush.horizontalGradient(
                        colors = listOf(
                            CallModalColors.rejectRed.copy(alpha = 0.2f + rejectProgress * 0.4f),
                            CallModalColors.glassSurface,
                            CallModalColors.answerGreen.copy(alpha = 0.2f + answerProgress * 0.4f)
                        )
                    )
                ),
            contentAlignment = Alignment.Center
        ) {
            // Left indicator (Reject)
            Box(
                modifier = Modifier
                    .align(Alignment.CenterStart)
                    .padding(start = 12.dp)
                    .size(if (rejectThresholdReached) 50.dp * pulseScale else 50.dp)
                    .alpha(0.3f + rejectProgress * 0.7f)
                    .clip(CircleShape)
                    .background(CallModalColors.rejectRed.copy(alpha = 0.3f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = Icons.Default.CallEnd,
                    contentDescription = "Decline",
                    tint = CallModalColors.rejectRed,
                    modifier = Modifier.size(24.dp)
                )
            }

            // Right indicator (Answer)
            Box(
                modifier = Modifier
                    .align(Alignment.CenterEnd)
                    .padding(end = 12.dp)
                    .size(if (answerThresholdReached) 50.dp * pulseScale else 50.dp)
                    .alpha(0.3f + answerProgress * 0.7f)
                    .clip(CircleShape)
                    .background(CallModalColors.answerGreen.copy(alpha = 0.3f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = Icons.Default.Call,
                    contentDescription = "Answer",
                    tint = CallModalColors.answerGreen,
                    modifier = Modifier.size(24.dp)
                )
            }

            // Draggable button in center
            Box(
                modifier = Modifier
                    .offset { IntOffset(animatedOffset.roundToInt(), 0) }
                    .size(buttonSize)
                    .clip(CircleShape)
                    .background(
                        Brush.radialGradient(
                            colors = when {
                                answerProgress > 0.5f -> listOf(
                                    CallModalColors.answerGreen,
                                    CallModalColors.answerGreenDark
                                )
                                rejectProgress > 0.5f -> listOf(
                                    CallModalColors.rejectRed,
                                    CallModalColors.rejectRedDark
                                )
                                else -> listOf(
                                    CallModalColors.cyberCyan,
                                    CallModalColors.plasmaBlue
                                )
                            }
                        )
                    )
                    .pointerInput(Unit) {
                        detectHorizontalDragGestures(
                            onDragStart = {
                                isDragging = true
                                haptic.performHapticFeedback(HapticFeedbackType.LongPress)
                            },
                            onDragEnd = {
                                isDragging = false

                                when {
                                    progress > 0.85f -> {
                                        // Answer threshold reached
                                        actionTriggered = true
                                        haptic.performHapticFeedback(HapticFeedbackType.LongPress)
                                        onAnswer()
                                    }
                                    progress < -0.85f -> {
                                        // Reject threshold reached
                                        actionTriggered = true
                                        haptic.performHapticFeedback(HapticFeedbackType.LongPress)
                                        onReject()
                                    }
                                    else -> {
                                        // Return to center
                                        dragOffset = 0f
                                    }
                                }
                            },
                            onDragCancel = {
                                isDragging = false
                                dragOffset = 0f
                            },
                            onHorizontalDrag = { _, dragAmount ->
                                dragOffset = (dragOffset + dragAmount).coerceIn(-maxDragPx, maxDragPx)

                                // Haptic feedback at thresholds
                                val newProgress = dragOffset / maxDragPx
                                if (newProgress.absoluteValue > 0.85f) {
                                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)
                                }
                            }
                        )
                    },
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = when {
                        answerProgress > 0.5f -> Icons.Default.Call
                        rejectProgress > 0.5f -> Icons.Default.CallEnd
                        else -> Icons.Default.Phone
                    },
                    contentDescription = "Slide",
                    tint = Color.White,
                    modifier = Modifier.size(32.dp)
                )
            }
        }

        Spacer(modifier = Modifier.height(12.dp))

        // Visual progress indicators
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text(
                text = "← Decline",
                color = CallModalColors.rejectRed.copy(alpha = 0.5f + rejectProgress * 0.5f),
                fontSize = 12.sp
            )
            Text(
                text = "Answer →",
                color = CallModalColors.answerGreen.copy(alpha = 0.5f + answerProgress * 0.5f),
                fontSize = 12.sp
            )
        }
    }
}

/**
 * In-call controls (mute, speaker, hold, keypad, end call)
 */
@Composable
private fun InCallControls(
    isMuted: Boolean,
    isSpeaker: Boolean,
    isOnHold: Boolean,
    onMuteToggle: (Boolean) -> Unit,
    onSpeakerToggle: (Boolean) -> Unit,
    onHoldToggle: (Boolean) -> Unit,
    onKeypadPress: (Char) -> Unit,
    onEndCall: () -> Unit
) {
    var showKeypad by remember { mutableStateOf(false) }

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.fillMaxWidth()
    ) {
        // Main controls row
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            // Mute
            ControlButton(
                icon = if (isMuted) Icons.Default.MicOff else Icons.Default.Mic,
                label = if (isMuted) "Unmute" else "Mute",
                isActive = isMuted,
                onClick = { onMuteToggle(!isMuted) }
            )

            // Keypad
            ControlButton(
                icon = Icons.Default.Dialpad,
                label = "Keypad",
                isActive = showKeypad,
                onClick = { showKeypad = !showKeypad }
            )

            // Speaker
            ControlButton(
                icon = if (isSpeaker) Icons.Default.VolumeUp else Icons.Default.VolumeDown,
                label = if (isSpeaker) "Speaker" else "Speaker",
                isActive = isSpeaker,
                onClick = { onSpeakerToggle(!isSpeaker) }
            )

            // Hold
            ControlButton(
                icon = if (isOnHold) Icons.Default.PlayArrow else Icons.Default.Pause,
                label = if (isOnHold) "Resume" else "Hold",
                isActive = isOnHold,
                onClick = { onHoldToggle(!isOnHold) }
            )
        }

        // Keypad (shown when active)
        AnimatedVisibility(
            visible = showKeypad,
            enter = expandVertically() + fadeIn(),
            exit = shrinkVertically() + fadeOut()
        ) {
            InCallKeypad(onKeyPress = onKeypadPress)
        }

        Spacer(modifier = Modifier.height(24.dp))

        // End call button
        Box(
            modifier = Modifier
                .size(72.dp)
                .clip(CircleShape)
                .background(
                    Brush.radialGradient(
                        colors = listOf(
                            CallModalColors.rejectRed,
                            CallModalColors.rejectRedDark
                        )
                    )
                )
                .pointerInput(Unit) {
                    detectHorizontalDragGestures { _, _ -> }
                },
            contentAlignment = Alignment.Center
        ) {
            IconButton(
                onClick = onEndCall,
                modifier = Modifier.fillMaxSize()
            ) {
                Icon(
                    imageVector = Icons.Default.CallEnd,
                    contentDescription = "End Call",
                    tint = Color.White,
                    modifier = Modifier.size(36.dp)
                )
            }
        }

        Text(
            text = "End Call",
            color = CallModalColors.rejectRed,
            fontSize = 12.sp,
            modifier = Modifier.padding(top = 8.dp)
        )
    }
}

/**
 * Control button for in-call actions
 */
@Composable
private fun ControlButton(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    label: String,
    isActive: Boolean,
    onClick: () -> Unit
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Box(
            modifier = Modifier
                .size(56.dp)
                .clip(CircleShape)
                .background(
                    if (isActive) CallModalColors.cyberCyan.copy(alpha = 0.3f)
                    else CallModalColors.glassSurface
                ),
            contentAlignment = Alignment.Center
        ) {
            IconButton(onClick = onClick) {
                Icon(
                    imageVector = icon,
                    contentDescription = label,
                    tint = if (isActive) CallModalColors.cyberCyan else CallModalColors.textPrimary,
                    modifier = Modifier.size(24.dp)
                )
            }
        }

        Text(
            text = label,
            color = CallModalColors.textMuted,
            fontSize = 11.sp,
            modifier = Modifier.padding(top = 4.dp)
        )
    }
}

/**
 * In-call keypad for DTMF tones
 */
@Composable
private fun InCallKeypad(
    onKeyPress: (Char) -> Unit
) {
    val keys = listOf(
        listOf('1', '2', '3'),
        listOf('4', '5', '6'),
        listOf('7', '8', '9'),
        listOf('*', '0', '#')
    )

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        keys.forEach { row ->
            Row(
                horizontalArrangement = Arrangement.SpaceEvenly,
                modifier = Modifier.fillMaxWidth()
            ) {
                row.forEach { key ->
                    TextButton(
                        onClick = { onKeyPress(key) },
                        modifier = Modifier.size(64.dp)
                    ) {
                        Text(
                            text = key.toString(),
                            color = CallModalColors.textPrimary,
                            fontSize = 24.sp,
                            fontWeight = FontWeight.Medium
                        )
                    }
                }
            }
        }
    }
}

/**
 * Call status badge
 */
@Composable
private fun CallStatusBadge(state: CallModalState) {
    val (text, color) = when (state) {
        CallModalState.RINGING -> "INCOMING" to CallModalColors.cyberCyan
        CallModalState.CONNECTING -> "CONNECTING" to CallModalColors.neonPurple
        CallModalState.ACTIVE -> "ACTIVE" to CallModalColors.answerGreen
        CallModalState.ENDED -> "ENDED" to CallModalColors.textMuted
    }

    Box(
        modifier = Modifier
            .clip(RoundedCornerShape(16.dp))
            .background(color.copy(alpha = 0.2f))
            .padding(horizontal = 16.dp, vertical = 6.dp)
    ) {
        Text(
            text = text,
            color = color,
            fontSize = 12.sp,
            fontWeight = FontWeight.Bold
        )
    }
}

/**
 * Caller avatar with pulse animation
 */
@Composable
private fun CallerAvatar(
    contactName: String?,
    isRinging: Boolean
) {
    val infiniteTransition = rememberInfiniteTransition(label = "avatarPulse")

    val pulseScale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = if (isRinging) 1.1f else 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(800, easing = EaseInOutSine),
            repeatMode = RepeatMode.Reverse
        ),
        label = "pulseScale"
    )

    val glowAlpha by infiniteTransition.animateFloat(
        initialValue = 0.3f,
        targetValue = if (isRinging) 0.7f else 0.3f,
        animationSpec = infiniteRepeatable(
            animation = tween(800, easing = EaseInOutSine),
            repeatMode = RepeatMode.Reverse
        ),
        label = "glowAlpha"
    )

    Box(
        modifier = Modifier
            .size(120.dp)
            .scale(pulseScale),
        contentAlignment = Alignment.Center
    ) {
        // Glow effect
        if (isRinging) {
            Box(
                modifier = Modifier
                    .size(120.dp)
                    .blur(20.dp)
                    .alpha(glowAlpha)
                    .clip(CircleShape)
                    .background(CallModalColors.cyberCyan)
            )
        }

        // Avatar circle
        Box(
            modifier = Modifier
                .size(100.dp)
                .clip(CircleShape)
                .background(
                    Brush.linearGradient(
                        colors = listOf(
                            CallModalColors.cyberCyan,
                            CallModalColors.neonPurple
                        )
                    )
                ),
            contentAlignment = Alignment.Center
        ) {
            val initial = contactName?.firstOrNull()?.uppercaseChar() ?: '?'
            Text(
                text = initial.toString(),
                color = Color.White,
                fontSize = 40.sp,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

/**
 * Animated background particles
 */
@Composable
private fun AnimatedBackground() {
    val infiniteTransition = rememberInfiniteTransition(label = "bg")

    val rotation by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 360f,
        animationSpec = infiniteRepeatable(
            animation = tween(60000, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ),
        label = "rotation"
    )

    // Subtle rotating gradient overlay
    Box(
        modifier = Modifier
            .fillMaxSize()
            .alpha(0.1f)
            .background(
                Brush.sweepGradient(
                    colors = listOf(
                        CallModalColors.cyberCyan,
                        Color.Transparent,
                        CallModalColors.neonPurple,
                        Color.Transparent,
                        CallModalColors.cyberCyan
                    )
                )
            )
    )
}

/**
 * Format duration in mm:ss
 */
private fun formatDuration(seconds: Long): String {
    val minutes = seconds / 60
    val secs = seconds % 60
    return "%02d:%02d".format(minutes, secs)
}

